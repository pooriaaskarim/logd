import 'package:logd/logd.dart';

/// This example demonstrates Content Decorators (`PrefixDecorator` and `SuffixDecorator`),
/// which mutate the actual content of each log line before structural or visual decorators
/// are applied.
void main() {
  print('=== Logd / Content Decorators Showcase ===\n');

  // SCENARIO 1: Semantic Prefixes
  // Prepends a fixed identifier to every line. Great for multi-service or multi-component logs.
  final prefixHandler = Handler(
    formatter: const PlainFormatter(metadata: {LogMetadata.timestamp}),
    decorators: [
      const PrefixDecorator(' [NETWORK-IO] '),
    ],
    sink: const ConsoleSink(),
  );

  Logger.configure('network', handlers: [prefixHandler]);
  Logger.get('network').info('Connecting to socket: 127.0.0.1:8080');
  Logger.get('network').info('Handshake complete.');

  print('\n${'=' * 60}\n');

  // SCENARIO 2: End-Aligned Suffixes
  // Perfect for "right-railing" status tags, timestamps, or session IDs.
  final statusHandler = Handler(
    formatter: const StructuredFormatter(),
    decorators: [
      const SuffixDecorator(' [v1.2.0-stable] ', aligned: true),
    ],
    sink: const ConsoleSink(),
    lineLength: 70,
  );

  Logger.configure('status', handlers: [statusHandler]);
  Logger.get('status').warning('High memory usage detected.');

  print('\n${'=' * 60}\n');

  // SCENARIO 3: Combinatorial Railing (Prefix + Aligned Suffix)
  // Wraps content between two identifying markers.
  final comboHandler = Handler(
    formatter: const PlainFormatter(metadata: {}),
    decorators: [
      const PrefixDecorator(' >>> '),
      const SuffixDecorator(' <<< ', aligned: true),
      const BoxDecorator(borderStyle: BorderStyle.rounded),
    ],
    sink: const ConsoleSink(),
    lineLength: 50,
  );

  Logger.configure('combo', handlers: [comboHandler]);
  Logger.get('combo').info('System initialized successfully.');
  Logger.get('combo').error('Permission denied: /var/log/audit.log');

  print('\n${'=' * 60}\n');

  // SCENARIO 4: Machine-Reading Helpers
  // Adding markers that are easy for regex or LLMs to pick up even in unstructured text.
  final machineHandler = Handler(
    formatter: const ToonFormatter(metadata: {}),
    decorators: [
      const PrefixDecorator('TOON_START|'),
      const SuffixDecorator('|TOON_END', aligned: false), // Attached
    ],
    sink: const ConsoleSink(),
  );

  Logger.configure('machine', handlers: [machineHandler]);
  Logger.get('machine').info('Heartbeat check: status=healthy');

  print('\n${'=' * 60}\n');

  // SCENARIO 5: Multi-line Suffixing
  // content decorators apply to EVERY line generated by the formatter.
  final multilineHandler = Handler(
    formatter: const PlainFormatter(metadata: {}),
    decorators: [
      const SuffixDecorator(' | TRACE-ID: 7a93f1', aligned: true),
    ],
    sink: const ConsoleSink(),
    lineLength: 40,
  );

  Logger.configure('trace', handlers: [multilineHandler]);
  Logger.get('trace').info('This is a multi-line message that will demonstrate '
      'how the suffix is applied consistently to the end '
      'of every single line wrapped by the formatter.');

  // SCENARIO 6: The "Dashboard" Rail (Double Prefix + Suffix + Box)
  // Demonstrates how multiple content decorators share the internal box space.
  final dashboardHandler = Handler(
    formatter: const PlainFormatter(metadata: {}),
    decorators: [
      const PrefixDecorator('[SYSTEM]'),
      const PrefixDecorator(' > '),
      const SuffixDecorator('[LIVE]', aligned: true),
      const BoxDecorator(borderStyle: BorderStyle.double),
      const StyleDecorator(),
    ],
    sink: const ConsoleSink(),
    lineLength: 60,
  );

  Logger.configure('dashboard', handlers: [dashboardHandler]);
  print('--- 6. Dashboard Rail (Complex Composition) ---');
  Logger.get('dashboard').info('Telemetry stream initialized.');
  Logger.get('dashboard').warning('Latency spike detected in region-us-east.');

  print('\n=== Content Decorators Showcase Complete ===');
}
